name: Smoke Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  smoke:
    runs-on: ubuntu-latest

    env:
      NODE_ENV: production
      DATABASE_URL: postgresql://test:test@localhost:5432/ggvibe_test
      REPL_ID: test-repl-id
      PORT: 5000
      NEXT_PUBLIC_APP_URL: http://localhost:5000

    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: ggvibe_test
        options: >-
          --health-cmd "pg_isready -U test -d ggvibe_test"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 10
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ggvibe/package-lock.json

      # SECURITY: never hardcode secret-like values in workflows.
      - name: Generate ephemeral SESSION_SECRET for this job
        shell: bash
        run: |
          set -euo pipefail
          echo "SESSION_SECRET=$(openssl rand -hex 32)" >> "$GITHUB_ENV"

      # DETERMINISM: use lockfile-driven installs
      - name: Install dependencies (ggvibe)
        run: npm ci --prefix ggvibe

      - name: Build application
        run: npm run build --prefix ggvibe

      - name: Start application in background
        shell: bash
        run: |
          set -euo pipefail
          cd ggvibe
          npm run start > ../server.log 2>&1 &
          echo "APP_PID=$!" >> "$GITHUB_ENV"
          echo "Started server PID=$!"

      # STABILITY: replace sleep with a real readiness gate + diagnostics
      - name: Wait for server readiness
        shell: bash
        run: |
          set -euo pipefail
          echo "Waiting for http://localhost:${PORT}/api/health ..."
          for i in $(seq 1 60); do
            if curl -fsS "http://localhost:${PORT}/api/health" >/dev/null 2>&1; then
              echo "Server is up."
              exit 0
            fi
            sleep 1
          done

          echo "❌ Server did not become ready in time."
          echo "---- last 200 lines of server.log ----"
          tail -n 200 server.log || true
          echo "---- process list ----"
          ps aux | head -n 30 || true
          exit 1

      - name: Verify OpenAI challenge endpoint
        shell: bash
        run: |
          set -euo pipefail
          echo "Testing: /.well-known/openai-apps-challenge"
          BODY="$(curl -fsS "http://localhost:${PORT}/.well-known/openai-apps-challenge")"

          if [ -z "${BODY}" ]; then
            echo "❌ FAILED: Challenge endpoint returned empty"
            exit 1
          fi

          # Guardrails: must be plain text token, not HTML/JSON
          if echo "${BODY}" | grep -qiE '<html|<!doctype|^{|^\['; then
            echo "❌ FAILED: Challenge endpoint returned non-plain-text content"
            echo "Response:"
            echo "${BODY}"
            exit 1
          fi

          echo "✅ PASSED: Challenge token is present (not printed for safety)."

      - name: Verify health endpoint
        shell: bash
        run: |
          set -euo pipefail
          echo "Testing: /api/health"
          HEALTH="$(curl -fsS "http://localhost:${PORT}/api/health")"
          echo "Response: ${HEALTH}"

          echo "${HEALTH}" | grep -q '"status"' || { echo "❌ FAILED: Health missing status"; exit 1; }
          echo "${HEALTH}" | grep -q '"appUrlConfigured"' || { echo "❌ FAILED: Health missing appUrlConfigured"; exit 1; }

          echo "✅ PASSED: Health endpoint OK"

      - name: Verify MCP endpoint
        shell: bash
        run: |
          set -euo pipefail
          echo "Testing: /mcp"
          MCP="$(curl -fsS "http://localhost:${PORT}/mcp")"
          echo "Response: ${MCP}"

          echo "${MCP}" | grep -q '"name"' || { echo "❌ FAILED: MCP missing name"; exit 1; }
          echo "${MCP}" | grep -q '"endpoints"' || { echo "❌ FAILED: MCP missing endpoints"; exit 1; }

          echo "✅ PASSED: MCP endpoint OK"

      - name: Test chat stream unauthorized
        shell: bash
        run: |
          set -euo pipefail
          echo "Testing: /api/v1/chat/stream (unauthorized)"
          STATUS="$(curl -s -o /dev/null -w "%{http_code}" -X POST "http://localhost:${PORT}/api/v1/chat/stream")"
          if [ "${STATUS}" != "401" ]; then
            echo "❌ FAILED: Expected 401, got ${STATUS}"
            exit 1
          fi
          echo "✅ PASSED: Unauthorized request returned 401"

      # Don’t force “authorized = 200” in CI unless you provide real auth + required secrets.
      # This avoids flaky/false-failures on forks and PRs where secrets are not available.
      - name: Test chat stream authorized (only when CI has a configured token)
        if: ${{ secrets.OPENAI_API_KEY != '' }}
        shell: bash
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          echo "Testing: /api/v1/chat/stream (authorized)"
          STATUS="$(curl -s -o /dev/null -w "%{http_code}" -X POST \
            -H "Authorization: Bearer test-token-12345" \
            -H "Content-Type: application/json" \
            "http://localhost:${PORT}/api/v1/chat/stream")"

          if [ "${STATUS}" != "200" ]; then
            echo "❌ FAILED: Expected 200, got ${STATUS}"
            echo "---- last 200 lines of server.log ----"
            tail -n 200 server.log || true
            exit 1
          fi
          echo "✅ PASSED: Authorized request returned 200"

      - name: Verify no rewrites intercept protected paths
        shell: bash
        run: |
          set -euo pipefail
          echo "Verifying next.config.mjs does not rewrite protected paths..."
          cd ggvibe

          # Only run checks if file exists (some repos use next.config.js/ts)
          test -f next.config.mjs || { echo "ℹ️ next.config.mjs not found, skipping"; exit 0; }

          # Broad, practical checks (avoid false positives on comments)
          if grep -nE '(\.well-known|/api/health|/mcp).*(destination|rewrite|rewrites)' next.config.mjs; then
            echo "❌ FAILED: next.config.mjs appears to rewrite protected paths"
            exit 1
          fi

          echo "✅ PASSED: No protected paths are rewritten"

      - name: Cleanup
        if: always()
        shell: bash
        run: |
          set +e
          if [ -n "${APP_PID:-}" ]; then
            echo "Stopping server PID=${APP_PID}"
            kill "${APP_PID}" || true
          fi
          echo "---- last 200 lines of server.log ----"
          tail -n 200 server.log || true
